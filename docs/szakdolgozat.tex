\documentclass[twoside, a4paper, 12pt]{article}
\usepackage{thesis-style}

\input{tex/adatok}

\title{\CIM}
\author{\SZERZO}
\date{\VEDESEVE}

\begin{document}
\pagestyle{empty}

% belső fedőlap
\include{tex/fedolap}
\cleardoublepage

% a belső fedőlap utáni lap a témabejelentő

% tartalomjegyzék
\tableofcontents
\cleardoublepage

\pagestyle{plain}
\setcounter{page}{1}

% tartalom
\input{tex/tartalom}

\section{Bevezetés}

\subsection{A dolgozat célja, motiváció}

Az alkalmazott matematikában nagyon fontos szerepet játszanak a prím számok, elég csak például a nyílt kulcsos titkosítási módszerekre gondolnunk. Ebből kifolyólag az évek során nagyon sok módszert fejlesztettek ki prímsázmok keresésére, például a Fermat-teszt, vagy a Miller-Rabin teszt. Ezen módszerekkel elég gyorsan el lehet dönteni egy darab számról, hogy prím-e vagy sem, és így ezért az ilyen algoritmusokkal nagyon nagy prímeket is meg lehet találni viszonylag gyorsan. \par
Előfordulhat azonban probléma, hogy egy adott intervallumban szeretnénk megtalálni az ott lévő összes prím számot. Az ilyen feladatok megoldására a leghatékonyabb módszerek a szitáló módszerek. Ezek úgy működnek, hogy kiválasztunk bizonyos számokat, és azokkal "végigszitálunk" a vizsgált intervallumon, és az érintetlenül hagyott számok lesznek a nekünk megfelelő, jelen esetben prím számok. Ezek közül is a legegyszerűbb egészen az ókorig nyúlik vissza, az ún. Erathosztenészi-szita. Ez az algoritmus ahhoz képest, hogy milyen rég óta ismert, meglepően hatékonyan működik. De természetesen vannak hátrányai, például hiába tűnik nagyon gyorsnak komplexitás szempontjából, elég nagy intervallumokra nagyon meg fog növekedni a memória olvasások száma, ami mint köztudott nagyságrendekkel lassabb, mint a processzorok utasítás végrehajtó képessége már a memóriában lévő adatokon. Nem meglepő módon sok féle képpen fel lehet javítani az algoritmus teljesítményét mai modern eszközökkel. \par
A dolgozat célja az, hogy a fent említett "naív" szitáló algoritmus teljesítményét növeljük, miközben a program skálázható is maradjon, és így a valós gyakorlati életben is alkalmazni lehessen. A dolgozat során két féle módon próbáltam meg javítani a teljesítményen.\par
Az első és talán legkézenfekvőbb módszer a program párhuzamosítása. Ezt viszonylag egyszerűen meg lehet tenni, mivel az algoritmust könnyedén fel lehet darabolni kisebb, egymással ekvivalens részfeladatokra, amiket szét lehet osztani a processzor szálai közt. Ráadásul a konkurens programokra jellenző veszélyek nem állnak fent, így sok nehézségtől meg tudjuk kímélni magunkat, ami a teljesítményt is javítja. \par
A másik megközelítés, hogy a memóriaműveletek számát próbáljuk meg minimalizálni. Erre egy hatékony megvalósítása az ún. COLS - cache optimalizált lineáris szita - algoritmus, aminek az megvalósítása is része a dolgozatnak.\par
Végül a fentiekből magától értetődik egy újabb gyorsítási lehetőség, hogy a COLS algoritmust is meg lehet valósítani párhuzamos szálakon, ami mint majd később látjuk megint csak nagy teljesítménynövekedéssel járhat.\par
A dolgozat során implementálva lett a fent említett négy algoritmus, és az volt vizsgálva, hogy milyen esetekben (a probléma mérete, hardver specifikációja) mennyire tudják, ha egyáltalán lehetséges, és mint kiderült nagyon is az, felgyorsítani a fenit módszerek a probléma megoldását. Az algoritmusokat C++ nyelvben valósítottam meg, csak és kizárólag a standard C++11 szabvány által kínált lehetőségeket felhasználva.\par \bigskip
Az elészített programmal könnyen és gyorsan lehet egy megadott intervallumon megkeresni a prím számokat, továbbá megfelelően paraméterezhető a rendelkezésre álló processzor(ok) tulajdonságainak ismeretében. A program jól skálázható, és elméletben akár nagyobb, sok központi számítóegységből álló konfigurációk, plédául szuperszámítógépeken is lehet használni, és így nagy, valós problémák megoldására is lehetőséget nyújt. \par \bigskip
A dolgozat során elkészített programot fel lehet használni többek között Cunningham-láncok keresésére is. Ezek a láncok egymáshoz közel elhelyezkedő prímekből állnak és felhasználják például az ún. Primecoin digitális fizetőeszköz bányászására. \par \bigskip
A COLS algoritmust, és a mögötte húzódó elméletet nem csak az Erathosztenészi-szita felgyorsítására lehet felhasználni, hanem többek között például az ún. SIQS algoritmus, vagyis az öninicializáló kvadratikus szita javítására is, ami egy elég hatékony faktorizáló algoritmus.

\clearpage
\section{Matematikai háttér}

\subsection{Prím számok, faktorizáció}

\begin{definition} Egy p természetes számot prímnek nevezünk, ha \(\forall a,b\)-re amire \(p|a \cdot b \rightarrow (p|a \vee p|b)\). \end{definition}
Természetes számok körében ez a definíció ekvivalens azzal, hogy egy prím számnak kettő, és csak kettő osztója van, 1 és önmaga. \par
A prím számok kitüntetett szerepet játszanak a matematikában. Többek közt felhasználják őket hasítótáblákhoz, pszeudovéletlen számok generálásához vagy nyílt kulcsú titkosításokhoz. Utóbbiak széles körben elterjedtek, valószínűleg sokan ismerik például az RSA kódolást, az SSH-t vagy a HTTPS-t. Ezek mind fontos részét képezik a modern kornak. A nyílt kulcsú kódolások olyan matematikai problémákon alapulnak, amelyeket megoldani nehéz, vagyis a mai eszközeinkkel valós időben nem lehetséges, viszont ellenőrizni egy lehetséges megoldást gyors és egyszerű. A leggyakrabban használt ilyen probléma a prím faktorizáció. \par
Számelmélet alaptétele: minden pozitív szám felírható egyértelműen prímszámok szorzatára. \par
Viszont, ennek a felbontásnak a megkeresése NP-nehéz probléma, vagyis nem tudunk jelenleg sokkal jobb módszert annál, mint hogy kipróbáljuk az összes lehetséges prím számot, hogy oszthója-e a felbontani kívánt számnak.\par
Tehát jól látszik, hogy a prím számok megtalálása  kiemelten fontos feladat. Rengeteg módszer létezik arra, hogy prímeket keressünk. A dolgozat az ún. szitáló módszerekkel foglalkozik, konkrétabban ezek felhasználása prímszámok keresésére. Ezeknek a módszereknek megvan az az előnye, hogy egy adott intervallumban megtalálják az összes ott előforduló prímet, viszont ha konkrétan csak egy darab számról akarjuk eldönteni, hogy prím-e, akkor ezeknél a módszereknél léteznek sokkal hatékonyabbak is.

\subsection{Eratoszthenészi-szita}

Az Eratoszthenészi-szita, mint a nevéből is látszik már egy nagyon régen ismert algoritmus. Ennek ellenére, bármilyen meglepő is, ha gyorsan meg akarjuk keresni egy intervallumban az összes prím számot, akkor ehhez az algoritmushoz kell visszanyúlnunk. Ez egy egyszerű kizárásos algoritmus. A számelmélet alaptétele szerint az intervallumunkban minden szám, amelyik nem prím, osztható nálánál kisebb prím szám(ok)kal. Tehát, ha lenne egy listánk a kisebb prímekről (ezt a táblát nevezzük szitatáblának), akkor azoknak meg tudnánk találni az intervallumunkban lévő többszöröseit, és amely szám egyik kis prímnek sem többszöröse, az prím szám. Ez az alap ötlet. \par
Az algoritumus: \par
\begin{enumerate}
\item Készítünk egy listát a kisebb prímekről, amelyekkel majd ki fogjuk szitálni a vizsgált intervallumot. Ezt a listát magát is el lehet készíteni egy kisebb Erathosztenészi szitával. \par
De mit is jelent az, hogy kis prímek? Jelöljük az intervallumunkat, ahol keressük a prímeket \( [a, b] \)-vel. A első ötlet természetesen, hogy vizsgálunk minden 1-nél nagyobb de \(b\)-nél kisebb prímszámot. De kicsit jobban belegondolva erre egyáltalán nincs szükség. \par 
TODO: insert ábra. \par
Elég $\sqrt{b}$-ig felmennünk a szitatábla felső korlátjával. Ahhoz, hogy ezt belássuk, vegyük észre, hogy minden a szitatáblában lévő, prímmel csak annak négyzetétől kell kezdenünk szitálni. \par 
Jelöljük a szitatáblát [x,y]-nal. Ekkor legyen $x < z < y$. Ekkorra már kiszitáltunk minden x és z közé eső prímmel. Vagyis azok a számok, amelyek oszthatóak valamely $z$-nél kisebb prímmel, már ki vannak szitálva. Vagyis az első olyan szám, amit vizsgálnunk kell, az a $z^2$. \par
Ebből már jól látszódik, egrészt az, hogy a fenti jelölést használva $y=\sqrt{b}$, másrészt ahogy haladunk előre a szitálóprímekkel, a vizsgált intervallum egyre kisebb lesz. Ez az egyszerűsítés rengeteget javít a program teljesítményén. Tfh. hogy $[x,y]=[10^6,4\cdot10^6]$. Ekkor a naív $4\cdot10^6$ szitatábla méret helyett elég mindössze $\sqrt{4\cdot10^6}=2000$ méretű tábla.
\item Legyen \textit{p} a szitatábla első eleme, a legkisebb prím: 2.
\item Jelöljük meg \textit{p} összes többszörösét a vizsgált intervallumban, kedzve $p^2$-től, ha $a<p^2 $. \label{szita}
\item Legyen \textit{p} a szitatábla következő eleme, a következő szitáló prím. Ha nincs ilyen akkor vége az algoritmusnak. Ha van ilyen, akkor folytassuk a \ref{szita}. ponttal.
\end{enumerate}
TODO: insert stuki \par
\bigskip
Az iteráció végén a jelöletlenül maradt számok lesznek a keresett prím számok. Ha egy ilyen szám összetett lenne, akkor már biztosan meg lett volna jelölve, hiszen a számelmélet alaptétele szerint felírható kisebb prímszámok szorzataként, vagyis egy kisebb prímszámnak a többszöröse, amikkel pedig már szitáltunk.
 \subsubsection{Hátrányok} \label{badbad}
Az algoritmus kisebb intervallumokra nagyon jól használható. A dolgozat során elvégzett mérések szerint körülbelül $2^17$-es nagyságrendig tartotta a lépést a később szóba kerülő COLS algoritmussal. De igazából algoritmikus módszerekkel nehéz tovább gyorsítani ezt a módszert. A nem prím számok kiszitálását nem tudjuk megúszni. \par
Viszont közismert tény, hogy a memória műveletek nagyságrendekkel lassabbak, mint ahogy egy processzor képes végrehajtani műveleteket a már meglévő, a cache memóriában tárolt adatokon. És itt jön ki igazából a nagy hátránya az Erathosztenészi-szitának. Mi történik akkor, ha akkora intervallumot akarunk vizsgálni, amekkora nem fér be a memóriába? \par
TODO: insert ábra \par
Ahogy az ábrán is látszódik, ilyen esetben nem tudunk végigszitálni egy adott kis prímmel az egész intervallumon. Amint elérjük a cache "végét", nem fogja találni a keresett következő számot a program, ezt hívják \textbf{cache miss}nek. Ilyenkor be kell kérni a hiányzó adatot jó esetben a RAM memóriából, rosszabb esetben a háttértárról. Ráadásul, amint kiszitáltunk egy prímmel, kezdhetjük beolvasni előről az összes adatot, jó esély van rá, hogy a processzor már kidobda az intervallum elején kiszitált számokat. Vagyis ez azt jelenti, hogy legrosszabb esetben az intervallum összes számát újra és újra be kell olvasni, egészen pontosan $\sqrt{b}$-szer. Mondani sem kell, hogy ez mennyire lelassítja az program teljesítményét. Sejteni lehet, hogy a vizsgált intervallum növekedésével nem egyenesen arányos a program futásának ideje. Ezt később be is látjuk majd, lásd: \ref{benchmark}

\subsection{Szegmensenkénit szitálás}

A \ref{badbad} fejezetben látott hátrányt mindenképp ki kell küszöbölni, ha valós környezetben is alkalmazható alkalmazást implementálni. Ugyanis a naív Erathosztenészi-szita nagyobb számok illetve intervallumok esetében az idő nagy részében a memóriából fog olvasni. Ez a probléma csak akkor fog jól látszódni, ha már akkora intervallumot szitálunk, ami nem fér bele a cache memóriába. Ez azért fordul elő, mert egyesével vesszük ki a prímeket a szitatáblából, és utána egyesével dolgozunk velük. Viszont ha megfordítanánk az algoritmust, és az intervallumból vennénk ki egy darabot, és ezzel dolgoznánk a szitatáblán, akkor megoldódna minden memória problémánk. Ugyanis a szitatábla mindössze $\sqrt{b}$ méretű, ami valószínűleg könnyedén elfér a lokális memóriában. \par 
Az előbb említett darabot, amit kiveszünk az intervallumból nevezzük szegmensnek, vagy angolul \textit{chunk}-nak. Ötlet: daraboljuk fel az egész intervallumot ilyen szegmensekre, és ezeket egyesével szitáljuk ki teljesen, majd írjuk vissza a memóriába. Így elérhetjük, hogy minden vizsgált szám mindössze egyszer kerüljön beolvasásra, nagyságrendekkel redukálva így a memória olvasások és írások számát. \par
Így tehát az algoritmus: \par
\begin{enumerate}
\item Készítsük el a kisebb prímekből alló szitatáblát a naív algoritmushoz hasonló módon.
\item Daraboljuk fel a vizsgált intervallumot alkalmasan sok szegmensre. Ara, hogy pontosan mennyire finom felosztás a legjobb választás nem lehet általánosan jó választ adni. Függ a használt számítógép specifikációjától. Valamint természetesen egy számítógép közben sok más dologra is használja a cache memóriáját, így nem lehet előre egy legjobb felosztást mondani. Ráadásul ha túl finom felosztást választunk, akkor pedig lehet, hogy csak felesleges overheadet okozunk a programnak. \par
Viszont kisebb, de már elég nagy példákon kísérletezve be lehet lőni azt, hogy körülbelül mi lenne a legmegfelelőbb felosztás.
\item Olvassuk be az első szegmenst a memóriába.
\item Legyen \textit{p} a szitatábla első eleme. \label{chunkszita}
\item Jelöljük meg \textit{p} összes többszörösét a beolvasott szegmensben, kezdve $p^2$-től, ha $a<p^2$.
\item Legyen \textit{p} a szitatáblából a következő szitáló prím. Ha nincs ilyen, akkor kész vagyunk az aktuális szegmens kiszitálásával, vagyis már akár ebből a szegmensből ki is lehetne olvasni a benne lévő prím számokat. Ekkor olvassuk be a következő szegmenst, és folytassuk a \ref{chunkszita}-es ponttal. \par
Ha viszont nincs több szegmens, akkor készen vagyunk, vége az algoritmusnak. 
\end{enumerate}
TODO: insert stuki \par
Amint később látni fogjuk, csak ezzel a módosítással volt, hogy több mint 3-szoros sebesség csökkenést lehetett elérni. Lásd: \ref{benchmark}
\subsection{COLS}

\clearpage
\section{Felhasználói dokumentáció}

\subsection{A program használata} \label{usage}

A program a \textbf{result/} mappába fogja elhelyezni a kiszámolt prímeket a result.txt fájlba, ha mást nem adtunk meg.\par
TODO: insert ábra

\subsection{Rendszerkövetelmények}

A program 64-bites Microsoft Windows operációs rendszer használatával íródott és lett tesztelve. (Windows 7 és 10) Így az ilyen operációs rendszereken biztosan helyesen működik. \par
Ahhoz, hogy UNIX alapú operációs rendszeren, illetve 32-bites rendszereken használni tudjuk, ahhoz újra kell fordítani a programot. Lásd: \ref{build} Ezeken a rendszereken nem lett tesztelve a program, de nem használja ki a használt operációs rendszer által nyújtott lehetőségeket, ezért portolható. De természetesen ajánlott a tesztelő program használata is más rendszereken való használat előtt.

\subsection{CD tartalma, telepítés}

A \textit{docs} mappában található a programhoz tartozó dokumentáció .pdf formátumban. \par
A \textit{source} mappában található a futtatható fájl, ennek neve sieve.exe. Ezt a fájlt futtatva indíthatjuk el a programot. Ebben a mappában találhatóak továbba a program forrásfájljai is.  A program konfigurálásához lásd: \ref{usage}. A program módosításához, illetve újrafordításához lásd: \ref{build} \par
A program teszteléséhez használt fájlok a \textit{test} mappában találhatóak. Bővebben lásd: \ref{test} \par
A \textit{result} mappába helyezi el a program a kiszámított eredményeket. Természetesen a CD-re nem tud írni a program. \par
A \textit{benchmark} mappában találhatóak a programban elkészített algoritmusok segítségéhez használt fájlok. Itt található még korábbi mérési eredmények benchmark\_result\_dátum.xlsx néven. \bigskip

\noindent \underline{Telepítés:} \par
A program használható közvetlenül a CD-ről is, bár ekkor nem tudjuk a kapott ererdményeket megteinteni. Ehhez a CD tartalmát másoljuk fel a használni kívánt számítógépre, és ezek után a program a fentebb említett \textit{result} mappába fogja másolni az eredményeit.

\clearpage
\section{Fejlesztői dokumentáció}

\subsection{Felhasznált technológiák}
A program C++ programozási nyelv standard C++11-es verziójának használatával íródott. Semmilyen külső könyvtárat nem használ, így könnyen újrafordíthatja és portolhatja más rendszerre bárki. \par
A párhuzamos szálakon történő futtatáshoz a standard C++11 által kínált \textbf{thread} könyvtár van felhasználva. \par
A program fejlesztése során a verziókövetésre a GitHub online verziókövető rendszer volt használva. Egy program implementációja során kiemelten fontos egy hasonló szolgáltatás használata. Ennek segítségével könnyedén nyomon lehet követni a program fejlesztésének történetét, és egyszerűen lehet több számítógépről is folytatni a fejlesztést. A program megtalálható az alábbi helyen: https://github.com/peterhuszti/Thesis-MSc \par
A program tesztelése szintén standard C++ segítsgével lett megoldva. A dolgozat során ahol lehetett próbáltam a C++11-es szabvány által nyújtott lehetőségeket kihasználni. Erre jó példa a thread könyvtár használata, ami egy nagyon egyszerű API-t kínál szálak definiálására és általában konkurens programok készítésére. Továbba ki van hasnzálva a C++-ban újdonságnak számító lambda kifejezések ereje is. Ezeknek a lambdáknak, vagy más néven névtelen eljárásoknak a különlegessége, hogy nem tartozik hozzájuk azonosító. Ezeket felhasnzálva egyszerűen tudunk eljárásokat paraméterül adni magasabb rendű függvényeknek, például szálak viselkedésének a megadásakor. \par
A benchmark elkészítéséhez a Benchpress nevű frameworköt használtam. Ez egy nagyon egyszerűen és könnyen használható eszköz, amivel C++11 nyelven írt programok, vagy akár csak külön függvények és eljárások futási sebességét lehet mérni. REF \par

\subsection{Fordítás} \label{build}

Ahhoz, hogy le tudjuk újra fordítani a programot, ahhoz egy C++11 kompatibilis fordítóra van szükség. A program eredetileg a g++ 5.2.0-ás verziójával lett lefordítva, de semmi akadálya annak, hogy más megfelelő fordítóprogramot használjunk. \par
Ha viszont g++-t használunk, akkor a következő javasolt g++ [-o sieve] -O3 -std=c++11 main.cpp. Az -o kapcsoló nem szükséges, ezzel csupán az elkészített futtatható fájl nevét tudjuk megadni. Az -std=c++11 paraméterrel tudjuk megadni, hogy a fordító a C++11-es szabvány szerint próbálja meg lefordítani a programot. Az -O3 paraméter egy optimalizációs paraméter. Ezekről bővebben lásd: \ref{optpar}

\subsection{A program felépítése}

\subsection{Adatszerkezetek}

\subsubsection{Szitatábla}
\subsubsection{Szegmensek}
\subsubsection{Körök és edények}

\subsection{Párhuzamos megvalósítás}

\subsection{Skálázhatóság} \label{scale}

\subsection{Tesztelés} \label{test}

\subsection{Továbbfejlesztési lehetőségek}

\clearpage
\section{Az algoritmusok összehasonlítása}

\subsection{Használt hardverek}

A dolgozat során kettő konfiguráción volt lehetőség tesztelni a program és az algoritmusok sebességét és teljesítményét: \bigskip \bigskip \bigskip

'A' konfiguráció ~~~~~~~~
\begin{tabular}{ | c | }
  \hline
  Intel Core i5-5300U @ 2.3GHz \\ \hline
  2 core, 4 thread \\ \hline
  3 MB cache \\ \hline
  Max. memória sávszélesség: 25.6 GB/s \\ \hline
  8 GB RAM\\ \hline
  64-bit Windows 7 \\
  \hline
\end{tabular}

\bigskip \bigskip

'B' konfiguráció ~~~~~~~~
\begin{tabular}{ | c | }
  \hline
  Intel Core i7-4790 @ 3.6GHz \\ \hline
  4 core, 8 thread \\ \hline
  8 MB cache \\ \hline
  Max. memória sávszélesség: 25.6 GB/s \\ \hline
  16 GB RAM\\ \hline
  64-bit Windows 10 \\
  \hline
\end{tabular}

\bigskip \bigskip

Érdemes megjegyezni, hogy az 'A' konfiguráció egy laptop, míg a 'B' egy asztali számítógép. Később jól fog látszódni a két számítógép közötti teljesítmény különbség. \par
Korábban volt szó a skálázhatóságról, lásd \ref{scale}. Érdekes lenne kipróbálni egy nagyobb, több processzort tartalmazó konfiguráción is a programot, de erre sajnos a dolgozat készítése során nem volt lehetőség.

\subsection{Fordítási paraméterek} \label{optpar}

\subsection{Az eredmények} \label{benchmark}

\subsection{Konklúzió}

\clearpage
\section{Összegzés}

\end{document}







































